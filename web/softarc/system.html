<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System - Beosound 5c</title>

    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="../assets/favicons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicons/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../assets/favicons/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="../assets/favicons/android-chrome-512x512.png">
    <link rel="manifest" href="../assets/favicons/site.webmanifest">
    <meta name="theme-color" content="#000000">

    <script>
        if (/Mac/.test(navigator.userAgent) && /^(localhost|127\.0\.0\.1)$/.test(location.hostname))
            document.write('<script src="system-mocks.js"><\/script>');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            cursor: none;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 40px 60px;
        }

        .section-nav {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .section-tab {
            font-size: 18px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: color 0.3s;
            cursor: pointer;
        }

        .section-tab.active {
            color: #fff;
        }

        .section-content {
            flex: 1;
            overflow-y: auto;
            display: none;
        }

        .section-content.active {
            display: block;
        }

        /* Info section */
        .info-section h1 {
            font-size: 32px;
            font-weight: 300;
            margin-bottom: 10px;
        }

        .info-section .version {
            font-size: 13px;
            color: #666;
            margin-bottom: 5px;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .info-section .repo-link {
            font-size: 12px;
            color: #0af;
            margin-bottom: 25px;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .info-section .description {
            font-size: 15px;
            line-height: 1.6;
            color: #aaa;
            max-width: 650px;
            margin-bottom: 20px;
        }

        .info-section .features {
            font-size: 13px;
            color: #888;
            margin-bottom: 25px;
        }

        .info-section .features li {
            margin-bottom: 6px;
            list-style: none;
        }

        .info-section .features li::before {
            content: "- ";
            color: #555;
        }

        .info-section .creator {
            font-size: 14px;
            color: #555;
        }

        .info-section .creator span {
            color: #888;
        }

        /* ── Services subcards ── */
        .services-section {
            position: relative;
        }

        .subcard-header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 18px;
        }

        .subcard-title {
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .subcard-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
            flex-shrink: 0;
        }

        .subcard-status-dot.online { background: #4a4; }
        .subcard-status-dot.offline { background: #a44; }
        .subcard-status-dot.warning { background: #fa0; }

        .subcard-counter {
            margin-left: auto;
            font-size: 12px;
            color: #555;
            letter-spacing: 1px;
        }

        .subcard-body {
            display: grid;
            grid-template-columns: 130px 1fr;
            gap: 4px 16px;
            font-size: 13px;
            max-width: 650px;
        }

        .subcard-body .label {
            color: #666;
            padding: 4px 0;
        }

        .subcard-body .value {
            color: #fff;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            padding: 4px 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .subcard-body .value.ok { color: #4a4; }
        .subcard-body .value.warn { color: #fa0; }
        .subcard-body .value.err { color: #a44; }

        .subcard-body .value.dim { color: #555; }

        /* Spotify digit grid */
        .digit-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-top: 6px;
            max-width: 500px;
        }

        .digit-item {
            background: #111;
            border: 1px solid #222;
            border-radius: 3px;
            padding: 4px 6px;
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .digit-item .digit-num {
            color: #555;
            margin-right: 4px;
        }

        .digit-item .digit-name {
            color: #999;
        }

        /* CD artwork */
        .cd-artwork {
            width: 80px;
            height: 80px;
            border-radius: 4px;
            background: #111;
            border: 1px solid #333;
            object-fit: cover;
            margin-top: 4px;
        }

        /* Service list in SYSTEM subcard */
        .svc-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px 20px;
            margin-top: 4px;
        }

        .svc-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 2px 0;
        }

        .svc-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #555;
            flex-shrink: 0;
        }

        .svc-dot.running { background: #4a4; }
        .svc-dot.stopped { background: #a44; }
        .svc-dot.warning { background: #fa0; }

        .svc-name {
            color: #888;
        }

        /* People section */
        .people-section .people-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 25px;
            max-width: 700px;
        }

        .person-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .person-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #555;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 300;
            color: #666;
            overflow: hidden;
            transition: border-color 0.3s;
        }

        .person-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .person-avatar.home {
            border-color: #4a4;
            box-shadow: 0 0 12px rgba(68, 170, 68, 0.3);
        }

        .person-avatar.away {
            border-color: #555;
        }

        .person-name {
            margin-top: 10px;
            font-size: 14px;
            color: #fff;
            text-align: center;
        }

        .person-status {
            margin-top: 4px;
            font-size: 11px;
            color: #666;
            text-transform: capitalize;
        }

        .person-status.home {
            color: #4a4;
        }

        .people-loading {
            color: #666;
            font-style: italic;
            font-size: 13px;
        }

        .people-error {
            color: #a44;
            font-size: 13px;
        }

        /* Remotes section */
        .remotes-section .remotes-content {
            max-width: 500px;
        }

        .remotes-section h3 {
            font-size: 13px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .supported-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px 30px;
            margin-bottom: 25px;
            font-size: 13px;
            color: #666;
        }

        .supported-list li {
            list-style: none;
            padding: 3px 0;
        }

        .supported-list li::before {
            content: "- ";
            color: #444;
        }

        .service-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .service-item.selected {
            background: #1a1a2a;
            border-color: #446;
        }

        .service-item.separator {
            margin-top: 10px;
            border-top: 1px solid #333;
            padding-top: 16px;
        }

        .service-item .name {
            color: #fff;
            font-size: 13px;
        }

        .service-item .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
        }

        .service-item .status-dot.running { background: #4a4; }
        .service-item .status-dot.warning { background: #fa0; }
        .service-item .status-dot.stopped { background: #a44; }

        .remote-item .mac {
            font-size: 11px;
            color: #555;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .remote-item .remote-meta {
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: #555;
        }

        .pairing-status {
            margin-top: 10px;
            font-size: 12px;
            color: #0af;
            min-height: 18px;
        }

        /* Section hint */
        .section-hint {
            margin-top: 15px;
            font-size: 11px;
            color: #444;
        }

        .section-hint .key {
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 3px;
            color: #666;
            margin-right: 3px;
        }

        /* Navigation hint at bottom */
        .nav-hint {
            position: fixed;
            bottom: 20px;
            left: 60px;
            right: 60px;
            display: flex;
            justify-content: center;
            gap: 40px;
            font-size: 11px;
            color: #333;
        }

        .nav-hint span {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-hint .key {
            background: #1a1a1a;
            padding: 3px 7px;
            border-radius: 3px;
            color: #555;
        }

        /* Meter bars (used in SYSTEM subcard) */
        .meter {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 2px 0;
            max-width: 300px;
        }

        .meter-bar {
            flex: 1;
            height: 5px;
            background: #1a1a1a;
            border-radius: 3px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .meter-label {
            font-size: 11px;
            color: #888;
            min-width: 40px;
            text-align: right;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* Scrollbar styling */
        .section-content::-webkit-scrollbar {
            width: 6px;
        }

        .section-content::-webkit-scrollbar-track {
            background: #111;
        }

        .section-content::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="app">
        <nav class="section-nav">
            <div class="section-tab active" data-section="info">Info</div>
            <div class="section-tab" data-section="services">Services</div>
            <div class="section-tab" data-section="remotes">Remotes</div>
            <div class="section-tab" data-section="people">People</div>
        </nav>

        <!-- Info Section -->
        <div class="section-content info-section active" id="info">
            <h1>BeoSound 5c</h1>
            <div class="version">Build: <span id="git-tag">--</span></div>
            <div class="repo-link">github.com/mkirsten/beosound5c</div>
            <p class="description">
                A modern software recreation of the iconic Bang & Olufsen BeoSound 5,
                bringing the classic circular arc interface back to life. Integrates with
                Sonos, Spotify, and Home Assistant for complete home entertainment control.
            </p>
            <ul class="features">
                <li>Original B&O laser pointer and navigation wheel hardware support</li>
                <li>Reverse-engineered MasterLink protocol for B&O IR remote integration</li>
                <li>BeoRemote One Bluetooth connectivity</li>
                <li>Real-time Sonos player control with artwork display</li>
                <li>Home Assistant webhook integration for smart home control</li>
            </ul>
            <div class="creator">Created by <span>Markus Kirsten</span></div>
        </div>

        <!-- Services Section (subcards) -->
        <div class="section-content services-section" id="services">
            <div id="subcard-container">
                <!-- Rendered by JS -->
            </div>
            <div class="section-hint">
                <span class="key">UP/DOWN</span> Navigate &nbsp;
                <span class="key">GO</span> Restart service
            </div>
        </div>

        <!-- Remotes Section -->
        <div class="section-content remotes-section" id="remotes">
            <div class="remotes-content">
                <h3>Supported IR Remotes</h3>
                <ul class="supported-list">
                    <li>Beo4 (all versions)</li>
                    <li>BeoLink 1000</li>
                    <li>BeoLink 5000</li>
                    <li>BeoLink 7000</li>
                    <li>BeoTime</li>
                    <li>Beo1</li>
                    <li>BeoSound 8 remote</li>
                    <li>AV Terminal</li>
                    <li>B&O KeyChain</li>
                    <li>BeoWatch</li>
                </ul>
                <div class="separator" style="border-top: 1px solid #333; margin-bottom: 20px;"></div>
                <h3>BeoRemote One (Bluetooth)</h3>
                <div class="services-list" id="remotes-list">
                    <span class="people-loading">Loading remotes...</span>
                </div>
                <div class="pairing-status" id="pairing-status"></div>
            </div>
            <div class="section-hint"><span class="key">GO</span> Pair new remote</div>
        </div>

        <!-- People Section -->
        <div class="section-content people-section" id="people">
            <div class="people-grid" id="people-grid">
                <span class="people-loading">Loading people...</span>
            </div>
        </div>

        <div class="nav-hint">
            <span><span class="key">LEFT/RIGHT</span> Sections</span>
            <span><span class="key">WHEEL</span> Scroll / Select</span>
        </div>
    </div>

    <script>
        // ── History buffer for sparkline charts ──
        const HISTORY = { cpu_temp: [], memory: [] };
        const HISTORY_MAX = 30;  // ~2.5 min at 5s refresh

        // ── Subcard definitions ──
        const SUBCARDS = [
            {
                id: 'overview',
                title: 'OVERVIEW',
                service: null,
                fetch: async () => {
                    const results = {};
                    await Promise.all([
                        fetch('http://localhost:8767/webhook', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ command: 'status' }),
                        }).then(r => r.json()).then(d => results.input = d).catch(() => {}),
                        fetch('http://localhost:8770/router/status')
                            .then(r => r.json()).then(d => results.router = d).catch(() => {}),
                        fetch('http://localhost:8766/player/status')
                            .then(r => r.json()).then(d => results.player = d).catch(() => {}),
                    ]);
                    return results;
                },
                render: (data) => {
                    const inp = data?.input || {};
                    const rtr = data?.router || {};
                    const plr = data?.player || {};
                    const sys = inp.system || {};
                    const cfg = inp.config || {};
                    const svcs = inp.services || {};

                    let html = '<div class="subcard-body">';
                    html += row('Device', cfg.DEVICE_NAME || sys.hostname);
                    html += row('IP', sys.ip_address);
                    html += row('Version', sys.git_tag || inp.git_tag);
                    html += row('Uptime', sys.uptime);

                    // Services summary
                    const total = Object.keys(svcs).length;
                    const running = Object.values(svcs).filter(s => s === 'Running').length;
                    if (total > 0) {
                        html += row('Services', `${running}/${total} running`, running === total ? 'ok' : 'warn');
                    }

                    // Sources configured
                    if (rtr.sources && Object.keys(rtr.sources).length > 0) {
                        const names = Object.values(rtr.sources).map(s => s.name);
                        html += row('Sources', names.join(', '));
                    }

                    // Audio output
                    html += row('Output', rtr.output_device || '—');

                    // Player
                    if (plr.player) {
                        const info = plr.player === 'sonos'
                            ? `Sonos — ${plr.speaker_name || '?'} (${plr.speaker_ip || '?'})`
                            : plr.player;
                        html += row('Player', info);
                    } else {
                        html += row('Player', rtr.active_player || '—');
                    }

                    html += '</div>';

                    // Show services with issues
                    const issues = Object.entries(svcs).filter(([_, s]) => s !== 'Running');
                    if (issues.length > 0) {
                        html += sectionLabel('Issues');
                        html += '<div class="svc-list">';
                        for (const [name, status] of issues) {
                            html += `<div class="svc-item"><span class="svc-dot stopped"></span><span class="svc-name">${name} (${status})</span></div>`;
                        }
                        html += '</div>';
                    }
                    return html;
                },
            },
            {
                id: 'system',
                title: 'SYSTEM',
                service: null,
                fetch: async () => {
                    const results = {};
                    await Promise.all([
                        fetch('http://localhost:8767/webhook', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ command: 'status' }),
                        }).then(r => r.json()).then(d => results.input = d).catch(() => {}),
                    ]);

                    // Accumulate history for charts
                    const sys = results.input?.system || {};
                    const temp = parseFloat(sys.cpu_temp);
                    if (!isNaN(temp)) {
                        HISTORY.cpu_temp.push(temp);
                        if (HISTORY.cpu_temp.length > HISTORY_MAX) HISTORY.cpu_temp.shift();
                    }
                    const memPct = parseMemPct(sys.memory);
                    if (memPct != null) {
                        HISTORY.memory.push(memPct);
                        if (HISTORY.memory.length > HISTORY_MAX) HISTORY.memory.shift();
                    }
                    results.history = { cpu_temp: [...HISTORY.cpu_temp], memory: [...HISTORY.memory] };
                    return results;
                },
                render: (data) => {
                    const inp = data?.input || {};
                    const sys = inp.system || {};
                    const svcs = inp.services || {};
                    const cfg = inp.config || {};
                    const hist = data?.history || {};

                    let html = '';

                    // Performance
                    html += sectionLabel('Performance');
                    html += '<div class="subcard-body">';
                    const temp = parseFloat(sys.cpu_temp);
                    html += row('CPU Temp', sys.cpu_temp, tempClass(sys.cpu_temp));
                    html += '</div>';
                    if (!isNaN(temp)) {
                        html += meterBar(temp, 85, tempColor(temp));
                        html += sparkline(hist.cpu_temp, 250, 24, tempColor(temp));
                    }

                    const memPct = parseMemPct(sys.memory);
                    html += '<div class="subcard-body">';
                    html += row('Memory', sys.memory);
                    html += '</div>';
                    if (memPct != null) {
                        const memCol = memPct > 85 ? '#a44' : memPct > 70 ? '#fa0' : '#4a4';
                        html += meterBar(memPct, 100, memCol);
                    }

                    // Network
                    html += sectionLabel('Network');
                    html += '<div class="subcard-body">';
                    html += row('Hostname', sys.hostname);
                    html += row('IP', sys.ip_address);
                    html += row('Device', cfg.DEVICE_NAME);
                    if (sys.interfaces) {
                        for (const [iface, info] of Object.entries(sys.interfaces)) {
                            html += row(iface, typeof info === 'string' ? info : JSON.stringify(info));
                        }
                    }
                    html += '</div>';

                    // All services
                    html += sectionLabel('All Services');
                    if (Object.keys(svcs).length > 0) {
                        html += '<div class="svc-list">';
                        for (const [name, status] of Object.entries(svcs)) {
                            const cls = status === 'Running' ? 'running' : (status === 'Inactive' || status === 'Failed') ? 'stopped' : 'warning';
                            html += `<div class="svc-item"><span class="svc-dot ${cls}"></span><span class="svc-name">${name.replace('beo-', '')}</span></div>`;
                        }
                        html += '</div>';
                    }
                    return html;
                },
            },
            {
                id: 'bluetooth',
                title: 'BLUETOOTH',
                service: 'beo-bluetooth',
                fetch: async () => {
                    const resp = await fetch('http://localhost:8767/bt/remotes');
                    if (!resp.ok) throw new Error('offline');
                    return resp.json();
                },
                render: (data) => {
                    if (!data || !Array.isArray(data)) return '<div class="subcard-body">' + row('Status', 'No data', 'dim') + '</div>';
                    let html = '';
                    for (const r of data) {
                        const name = r.name === 'BEORC' ? 'BeoRemote One' : r.name;
                        html += '<div class="subcard-body" style="margin-bottom:12px">';
                        html += row('Remote', name);
                        html += row('MAC', r.mac);
                        html += row('Connected', r.connected ? 'Yes' : 'No', r.connected ? 'ok' : 'err');
                        html += row('RSSI', r.rssi != null ? r.rssi + ' dBm' : '—');
                        html += row('Battery', r.battery != null ? r.battery + '%' : '—');
                        html += '</div>';
                    }
                    if (data.length === 0) {
                        html = '<div class="subcard-body">' + row('Remotes', 'None paired', 'dim') + '</div>';
                    }
                    return html;
                },
            },
            {
                id: 'masterlink',
                title: 'MASTERLINK',
                service: 'beo-masterlink',
                fetch: async () => {
                    const resp = await fetch('http://localhost:8768/mixer/status');
                    if (!resp.ok) throw new Error('offline');
                    return resp.json();
                },
                render: (data) => {
                    if (!data) return '<div class="subcard-body">' + row('Status', 'No data', 'dim') + '</div>';
                    let html = '<div class="subcard-body">';
                    html += row('USB', data.usb_connected ? 'Connected' : 'Not found', data.usb_connected ? 'ok' : 'err');
                    if (data.volume !== undefined) html += row('Volume', data.volume);
                    if (data.mute !== undefined) html += row('Mute', data.mute ? 'Yes' : 'No');
                    if (data.speakers_on !== undefined) html += row('Speakers', data.speakers_on ? 'On' : 'Off');
                    html += '</div>';
                    return html;
                },
            },
            {
                id: 'sonos',
                title: 'SONOS',
                service: 'beo-player-sonos',
                fetch: async () => {
                    const resp = await fetch('http://localhost:8766/player/status');
                    if (!resp.ok) throw new Error('offline');
                    return resp.json();
                },
                render: (data) => {
                    if (!data) return '<div class="subcard-body">' + row('Status', 'No data', 'dim') + '</div>';
                    let html = '<div class="subcard-body">';
                    html += row('Speaker', data.speaker_name);
                    html += row('IP', data.speaker_ip);
                    html += row('State', data.state, data.state === 'playing' ? 'ok' : '');
                    if (data.volume !== undefined && data.volume !== null) html += row('Volume', data.volume + '%');
                    if (data.current_track) {
                        html += row('Track', trunc(data.current_track.title, 40));
                        html += row('Artist', trunc(data.current_track.artist, 40));
                        html += row('Album', trunc(data.current_track.album, 40));
                    }
                    html += row('Grouped', data.is_grouped ? data.coordinator_name : 'No');
                    html += row('Art Cache', data.artwork_cache_size + ' items');
                    html += row('WS Clients', data.ws_clients);
                    html += '</div>';
                    return html;
                },
            },
            {
                id: 'spotify',
                title: 'SPOTIFY',
                service: 'beo-source-spotify',
                fetch: async () => {
                    const resp = await fetch('http://localhost:8771/status');
                    if (!resp.ok) throw new Error('offline');
                    return resp.json();
                },
                render: (data) => {
                    if (!data) return '<div class="subcard-body">' + row('Status', 'No data', 'dim') + '</div>';
                    let html = '<div class="subcard-body">';
                    html += row('Account', data.display_name || '—');
                    html += row('Auth', data.has_credentials ? (data.needs_reauth ? 'Expired' : 'OK') : 'Not connected',
                        data.has_credentials ? (data.needs_reauth ? 'warn' : 'ok') : 'err');
                    html += row('State', data.state);
                    html += row('Playlists', data.playlist_count);
                    html += row('Fetching', data.fetching ? 'Yes' : 'No', data.fetching ? 'warn' : '');
                    if (data.last_refresh) {
                        const d = new Date(data.last_refresh);
                        html += row('Last Refresh', d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
                    }
                    if (data.last_refresh_duration != null) {
                        html += row('Refresh Time', data.last_refresh_duration + 's');
                    }
                    html += '</div>';

                    // Digit playlists grid
                    if (data.digit_playlists && Object.keys(data.digit_playlists).length > 0) {
                        html += '<div style="margin-top:12px; font-size:11px; color:#555; text-transform:uppercase; letter-spacing:1px; margin-bottom:6px">Digit Playlists</div>';
                        html += '<div class="digit-grid">';
                        for (let i = 0; i <= 9; i++) {
                            const name = data.digit_playlists[String(i)] || '—';
                            html += `<div class="digit-item"><span class="digit-num">${i}</span><span class="digit-name">${trunc(name, 14)}</span></div>`;
                        }
                        html += '</div>';
                    }
                    return html;
                },
            },
            {
                id: 'cd',
                title: 'CD',
                service: 'beo-source-cd',
                fetch: async () => {
                    const resp = await fetch('http://localhost:8769/status');
                    if (!resp.ok) throw new Error('offline');
                    return resp.json();
                },
                render: (data) => {
                    if (!data) return '<div class="subcard-body">' + row('Status', 'No data', 'dim') + '</div>';
                    let html = '<div class="subcard-body">';
                    html += row('Drive', data.drive_connected ? 'Connected' : 'Not found', data.drive_connected ? 'ok' : 'err');
                    html += row('Disc', data.disc_inserted ? 'Inserted' : 'Empty', data.disc_inserted ? 'ok' : '');
                    if (data.metadata) {
                        html += row('Artist', trunc(data.metadata.artist, 35));
                        html += row('Album', trunc(data.metadata.title, 35));
                        if (data.metadata.musicbrainz) html += row('MusicBrainz', 'Yes', 'ok');
                    }
                    if (data.playback) {
                        html += row('State', data.playback.state, data.playback.state === 'playing' ? 'ok' : '');
                        if (data.playback.current_track) {
                            html += row('Track', data.playback.current_track + ' / ' + data.playback.total_tracks);
                        }
                    }
                    if (data.current_sink) {
                        const active = data.audio_outputs?.find(o => o.name === data.current_sink);
                        html += row('Output', active?.label || data.current_sink);
                    }
                    html += '</div>';

                    // Artwork
                    if (data.metadata?.artwork) {
                        html += `<img class="cd-artwork" src="${data.metadata.artwork}" alt="Album art">`;
                    }
                    return html;
                },
            },
        ];

        // ── Helper functions ──

        function row(label, value, cls) {
            const v = value != null ? value : '—';
            const c = cls ? ` ${cls}` : '';
            return `<span class="label">${label}</span><span class="value${c}">${v}</span>`;
        }

        function trunc(str, max) {
            if (!str) return '—';
            return str.length > max ? str.substring(0, max) + '...' : str;
        }

        function tempClass(temp) {
            if (!temp) return '';
            const n = parseFloat(temp);
            if (isNaN(n)) return '';
            return n > 70 ? 'err' : n > 55 ? 'warn' : 'ok';
        }

        function tempColor(temp) {
            if (temp < 50) return '#4a4';
            if (temp < 65) return '#fa0';
            return '#a44';
        }

        function sectionLabel(text) {
            return `<div style="margin-top:14px;font-size:11px;color:#555;text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">${text}</div>`;
        }

        function meterBar(value, max, color) {
            const pct = Math.min(100, Math.max(0, (value / max) * 100));
            return `<div class="meter"><div class="meter-bar"><div class="meter-fill" style="width:${pct.toFixed(0)}%;background:${color}"></div></div><span class="meter-label">${pct.toFixed(0)}%</span></div>`;
        }

        function sparkline(values, width, height, color) {
            if (!values || values.length < 2) return '';
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;
            const step = width / (values.length - 1);
            const c = color || '#4a4';
            const points = values.map((v, i) =>
                `${(i * step).toFixed(1)},${(height - 1 - ((v - min) / range) * (height - 2)).toFixed(1)}`
            ).join(' ');
            return `<svg width="${width}" height="${height}" style="display:block;margin:4px 0"><polyline points="${points}" fill="none" stroke="${c}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        }

        function parseMemPct(memStr) {
            if (!memStr) return null;
            let m = memStr.match(/(\d+(?:\.\d+)?)\s*%/);
            if (m) return parseFloat(m[1]);
            m = memStr.match(/(\d+(?:\.\d+)?)\s*[GMK]?\s*\/\s*(\d+(?:\.\d+)?)/);
            if (m) return (parseFloat(m[1]) / parseFloat(m[2])) * 100;
            return null;
        }


        class SystemPanel {
            constructor() {
                this.sections = ['info', 'services', 'remotes', 'people'];
                this.currentSection = 0;
                this.inputWs = null;
                this.serviceStatus = {};
                this.remoteItems = [];
                this.currentRemoteItem = 0;
                this.btRemotes = [];
                this.remotesRefreshInterval = null;

                // Service subcards
                this.currentSubcard = 0;
                this.subcardData = {};    // id -> last fetched data
                this.subcardOnline = {};  // id -> bool
                this.subcardRefreshTimer = null;

                // Debouncing
                this.lastButtonTime = 0;
                this.buttonDebounceMs = 200;
                this.lastNavTime = 0;
                this.navDebounceMs = 80;

                this.init();
            }

            init() {
                this._messageHandler = (event) => {
                    this.handleMessage(event.data);
                };
                window.addEventListener('message', this._messageHandler);

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') this.handleButton('left');
                    else if (e.key === 'ArrowRight') this.handleButton('right');
                    else if (e.key === 'ArrowUp') this.handleNav('counter', 1);
                    else if (e.key === 'ArrowDown') this.handleNav('clock', 1);
                    else if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.handleButton('go');
                    }
                });

                // Tab click handlers
                document.querySelectorAll('.section-tab').forEach((tab, index) => {
                    tab.addEventListener('click', () => {
                        this.currentSection = index;
                        this.updateSection();
                    });
                });

                this.connectInputWebSocket();
                this.fetchPeople();
                this.fetchBTRemotes();

                this._intervals = [
                    setInterval(() => this.fetchPeople(), 30000),
                ];
            }

            // ── Subcards ──

            async fetchSubcard(index) {
                const card = SUBCARDS[index];
                try {
                    const data = await card.fetch();
                    this.subcardData[card.id] = data;
                    this.subcardOnline[card.id] = !!data;
                } catch (e) {
                    this.subcardOnline[card.id] = false;
                }
                if (this.currentSubcard === index && this.sections[this.currentSection] === 'services') {
                    this.renderCurrentSubcard();
                }
            }

            renderCurrentSubcard() {
                const card = SUBCARDS[this.currentSubcard];
                const data = this.subcardData[card.id];
                const online = this.subcardOnline[card.id] !== false;

                const container = document.getElementById('subcard-container');
                let html = '<div class="subcard-header">';
                html += `<span class="subcard-status-dot ${online ? 'online' : 'offline'}"></span>`;
                html += `<span class="subcard-title">${card.title}</span>`;
                html += `<span class="subcard-counter">${this.currentSubcard + 1} / ${SUBCARDS.length}</span>`;
                html += '</div>';

                if (!online) {
                    html += '<div class="subcard-body">';
                    html += row('Status', 'Offline', 'err');
                    html += '</div>';
                } else {
                    try {
                        html += card.render(data);
                    } catch (e) {
                        html += '<div class="subcard-body">' + row('Error', e.message, 'err') + '</div>';
                    }
                }

                container.innerHTML = html;

                // Update git tag from system data (overview and system both fetch it)
                const tag = data?.input?.system?.git_tag || data?.input?.git_tag;
                if ((card.id === 'overview' || card.id === 'system') && tag) {
                    document.getElementById('git-tag').textContent = tag;
                }
            }

            startSubcardRefresh() {
                this.stopSubcardRefresh();
                this.fetchSubcard(this.currentSubcard);
                this.subcardRefreshTimer = setInterval(() => {
                    this.fetchSubcard(this.currentSubcard);
                }, 5000);
            }

            stopSubcardRefresh() {
                if (this.subcardRefreshTimer) {
                    clearInterval(this.subcardRefreshTimer);
                    this.subcardRefreshTimer = null;
                }
            }

            // ── WebSocket ──

            connectInputWebSocket() {
                try {
                    this.inputWs = new WebSocket('ws://localhost:8765');

                    this.inputWs.onopen = () => {
                        console.log('[SYSTEM] Input WS connected');
                        // Fetch system info for git tag
                        this.inputWs.send(JSON.stringify({
                            type: 'command', command: 'get_system_info'
                        }));
                    };

                    this.inputWs.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'system_info') {
                                if (data.git_tag) {
                                    document.getElementById('git-tag').textContent = data.git_tag;
                                }
                            } else if (data.type === 'bt_remotes') {
                                this.btRemotes = data.remotes || [];
                                this.renderRemotesList(this.btRemotes);
                            } else if (data.type === 'bt_pairing') {
                                const statusEl = document.getElementById('pairing-status');
                                if (data.status === 'started') {
                                    statusEl.textContent = data.message || 'Scanning...';
                                } else if (data.status === 'completed') {
                                    statusEl.textContent = data.message || 'Pairing complete';
                                    this.fetchBTRemotes();
                                    setTimeout(() => { statusEl.textContent = ''; }, 5000);
                                } else if (data.status === 'error') {
                                    statusEl.textContent = data.message || 'Pairing failed';
                                    setTimeout(() => { statusEl.textContent = ''; }, 5000);
                                }
                            }
                        } catch (e) {}
                    };

                    this.inputWs.onerror = () => {};

                    this.inputWs.onclose = () => {
                        setTimeout(() => this.connectInputWebSocket(), 5000);
                    };
                } catch (e) {
                    console.error('[SYSTEM] WebSocket error:', e);
                }
            }

            // ── Navigation ──

            handleMessage(msg) {
                if (msg.type === 'button') this.handleButton(msg.button);
                else if (msg.type === 'nav') {
                    const data = msg.data || msg;
                    this.handleNav(data.direction, data.speed || 1);
                }
            }

            handleButton(button) {
                const now = Date.now();
                if (now - this.lastButtonTime < this.buttonDebounceMs) return;
                this.lastButtonTime = now;

                const section = this.sections[this.currentSection];

                if (button === 'left') {
                    this.currentSection = (this.currentSection - 1 + this.sections.length) % this.sections.length;
                    this.updateSection();
                } else if (button === 'right') {
                    this.currentSection = (this.currentSection + 1) % this.sections.length;
                    this.updateSection();
                } else if (button === 'go') {
                    if (section === 'services') {
                        this.restartSubcardService();
                    } else if (section === 'remotes') {
                        const selected = this.remoteItems[this.currentRemoteItem];
                        if (selected && selected.dataset.action === 'pair') {
                            this.startBTPairing();
                        }
                    }
                }
            }

            handleNav(direction, speed) {
                const now = Date.now();
                if (now - this.lastNavTime < this.navDebounceMs) return;
                this.lastNavTime = now;

                const section = this.sections[this.currentSection];

                if (section === 'services') {
                    if (direction === 'counter') {
                        this.currentSubcard = (this.currentSubcard - 1 + SUBCARDS.length) % SUBCARDS.length;
                    } else if (direction === 'clock') {
                        this.currentSubcard = (this.currentSubcard + 1) % SUBCARDS.length;
                    }
                    this.startSubcardRefresh();
                } else if (section === 'remotes') {
                    if (this.remoteItems.length > 0) {
                        if (direction === 'counter') {
                            this.currentRemoteItem = Math.max(0, this.currentRemoteItem - 1);
                        } else if (direction === 'clock') {
                            this.currentRemoteItem = Math.min(this.remoteItems.length - 1, this.currentRemoteItem + 1);
                        }
                        this.updateRemoteSelection();
                    }
                }
            }

            updateSection() {
                document.querySelectorAll('.section-tab').forEach((tab, index) => {
                    tab.classList.toggle('active', index === this.currentSection);
                });

                document.querySelectorAll('.section-content').forEach((content) => {
                    content.classList.toggle('active', this.sections.indexOf(content.id) === this.currentSection);
                });

                const section = this.sections[this.currentSection];

                // Start/stop subcard refresh
                if (section === 'services') {
                    this.startSubcardRefresh();
                } else {
                    this.stopSubcardRefresh();
                }

                // Fetch remotes when entering remotes section
                if (section === 'remotes') {
                    this.fetchBTRemotes();
                    this.remotesRefreshInterval = setInterval(() => this.fetchBTRemotes(), 10000);
                } else {
                    if (this.remotesRefreshInterval) {
                        clearInterval(this.remotesRefreshInterval);
                        this.remotesRefreshInterval = null;
                    }
                }

                if (section === 'people') {
                    this.fetchPeople();
                }
            }

            // ── Service restart ──

            restartSubcardService() {
                const card = SUBCARDS[this.currentSubcard];
                if (!card.service) {
                    // SYSTEM card — restart all
                    if (this.inputWs && this.inputWs.readyState === WebSocket.OPEN) {
                        this.inputWs.send(JSON.stringify({
                            type: 'command', command: 'restart_service',
                            params: { action: 'restart-all' }
                        }));
                    }
                    return;
                }

                // Flash feedback
                const container = document.getElementById('subcard-container');
                container.style.opacity = '0.5';
                setTimeout(() => { container.style.opacity = '1'; }, 400);

                if (this.inputWs && this.inputWs.readyState === WebSocket.OPEN) {
                    const action = 'restart-' + card.service.replace('beo-', '');
                    this.inputWs.send(JSON.stringify({
                        type: 'command', command: 'restart_service',
                        params: { action: action }
                    }));
                }

                // Refresh after a short delay
                setTimeout(() => this.fetchSubcard(this.currentSubcard), 3000);
            }

            // ── BT Remotes ──

            async fetchBTRemotes() {
                try {
                    const resp = await fetch('http://localhost:8767/bt/remotes');
                    if (resp.ok) {
                        const remotes = await resp.json();
                        this.btRemotes = remotes;
                        this.renderRemotesList(remotes);
                        return;
                    }
                } catch (e) {}

                if (this.inputWs && this.inputWs.readyState === WebSocket.OPEN) {
                    this.inputWs.send(JSON.stringify({ type: 'command', command: 'get_bt_remotes' }));
                }
            }

            renderRemotesList(remotes) {
                const list = document.getElementById('remotes-list');
                if (!remotes || remotes.length === 0) {
                    list.innerHTML = '<span class="people-loading">No paired BeoRemote devices</span>';
                    this.remoteItems = [];
                    this.currentRemoteItem = 0;
                    return;
                }

                let html = remotes.map((r, i) => {
                    const statusClass = r.connected ? 'running' : 'stopped';
                    const rssiText = r.rssi != null ? `${r.rssi} dBm` : '—';
                    const batteryText = r.battery != null ? `${r.battery}%` : '—';
                    const selected = i === this.currentRemoteItem ? ' selected' : '';
                    const displayName = r.name === 'BEORC' ? 'BeoRemote One Bluetooth' : r.name;
                    return `
                        <div class="service-item remote-item${selected}" data-mac="${r.mac}">
                            <div>
                                <span class="name">${displayName}</span>
                                <div class="mac">${r.mac}</div>
                                <div class="remote-meta">
                                    <span>RSSI: ${rssiText}</span>
                                    <span>Battery: ${batteryText}</span>
                                </div>
                            </div>
                            <span class="status-dot ${statusClass}"></span>
                        </div>
                    `;
                }).join('');

                const pairSelected = remotes.length === this.currentRemoteItem ? ' selected' : '';
                html += `
                    <div class="service-item separator${pairSelected}" data-action="pair">
                        <span class="name">Pair New Remote</span>
                        <span class="status-dot"></span>
                    </div>
                `;

                list.innerHTML = html;
                this.remoteItems = list.querySelectorAll('.service-item');
            }

            updateRemoteSelection() {
                this.remoteItems.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.currentRemoteItem);
                });
            }

            startBTPairing() {
                const statusEl = document.getElementById('pairing-status');
                statusEl.textContent = 'Scanning for remotes... (60s)';

                if (this.inputWs && this.inputWs.readyState === WebSocket.OPEN) {
                    this.inputWs.send(JSON.stringify({ type: 'command', command: 'start_bt_pairing' }));
                } else {
                    fetch('http://localhost:8767/bt/remotes', { method: 'POST' }).catch(() => {});
                }

                setTimeout(() => {
                    statusEl.textContent = '';
                    this.fetchBTRemotes();
                }, 60000);
            }

            // ── People ──

            async fetchPeople() {
                const grid = document.getElementById('people-grid');
                try {
                    const resp = await fetch('http://localhost:8767/people');
                    if (!resp.ok) throw new Error('Failed to fetch');
                    const people = await resp.json();

                    if (people.error) {
                        grid.innerHTML = `<span class="people-error">Error: ${people.error}</span>`;
                        return;
                    }

                    if (people.length === 0) {
                        grid.innerHTML = '<span class="people-loading">No people found</span>';
                        return;
                    }

                    grid.innerHTML = people.map(person => {
                        const isHome = person.state === 'home';
                        const initials = this.getInitials(person.friendly_name);
                        const avatarContent = person.entity_picture
                            ? `<img src="${person.entity_picture}" alt="${person.friendly_name}" onerror="this.parentElement.innerHTML='${initials}'">`
                            : initials;
                        return `
                            <div class="person-card">
                                <div class="person-avatar ${isHome ? 'home' : 'away'}">${avatarContent}</div>
                                <div class="person-name">${person.friendly_name}</div>
                                <div class="person-status ${isHome ? 'home' : ''}">${person.state.replace('_', ' ')}</div>
                            </div>
                        `;
                    }).join('');
                } catch (e) {
                    if (grid.querySelector('.people-loading')) {
                        grid.innerHTML = '<span class="people-error">Unable to connect to Home Assistant</span>';
                    }
                }
            }

            getInitials(name) {
                return name.split(' ')
                    .map(part => part.charAt(0).toUpperCase())
                    .slice(0, 2)
                    .join('');
            }

            destroy() {
                if (this._intervals) {
                    this._intervals.forEach(id => clearInterval(id));
                    this._intervals = null;
                }
                if (this.remotesRefreshInterval) {
                    clearInterval(this.remotesRefreshInterval);
                    this.remotesRefreshInterval = null;
                }
                this.stopSubcardRefresh();
                if (this._messageHandler) {
                    window.removeEventListener('message', this._messageHandler);
                    this._messageHandler = null;
                }
                if (this.inputWs) {
                    this.inputWs.close();
                    this.inputWs = null;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.systemPanel = new SystemPanel();
        });
    </script>
</body>
</html>
